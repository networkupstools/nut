Network UPS Tools Developer Guide
=================================
Charles Lepple <clepple@gmail.com>

image::images/nut-banner.png[Network UPS Tools logo]

WARNING: this is a Work In Progress document.

Introduction
------------

...

Design
------

This software is designed around a layered scheme with drivers, a server and
clients. These layers communicate with text-based protocols for easier
maintenance and diagnostics.

The layering
~~~~~~~~~~~~

--------------------------------------
  CLIENTS: upsmon, upsc, upsrw, upsstats, upsset, etc. (via upsclient)

           < network: TCP sockets, typically on port 3493 >

   SERVER: upsd

           < Unix domain sockets with text-based messages >

  DRIVERS: apcsmart, bestups, powercom, etc.

           < serial communications, SNMP, USB, etc. >

EQUIPMENT: Smart-UPS 700, Fenton PowerPal 660, etc. (actual UPS hardware)
--------------------------------------

How information gets around
~~~~~~~~~~~~~~~~~~~~~~~~~~~

From the equipment
^^^^^^^^^^^^^^^^^^

DRIVERS talk to the EQUIPMENT and receive updates.  For most hardware this
is polled (DRIVER asks EQUIPMENT about a variable), but forced updates are
also possible.  The exact method is not important, as it is abstracted
by the driver.

From the driver
^^^^^^^^^^^^^^^

The core of all DRIVERS maintains internal storage for every variable
that is known along with the auxiliary data for those variables.  It 
sends updates to this data to any process which connects to the Unix
domain socket.

The DRIVERS will also provide a full atomic copy of their internal
knowledge upon receiving the "DUMPALL" command on the socket.  The dump
is in the same format as updates, and is followed by "DUMPDONE".  When
"DUMPDONE" has been received, the view is complete.

The SERVER will connect to the socket of each DRIVER and will request a
dump at that time.  It retains this data in local storage for later use.
It continues to listen on the socket for additional updates.

This protocol is documented in the <<sock-protocol,Unix socket protocol>> section.

From the server
^^^^^^^^^^^^^^^

The SERVER's internal storage maintains a complete copy of the data
which is in the DRIVER, so it is capable of answering any request
immediately.  When a request for data arrives from a CLIENT, the SERVER
looks through the internal storage for that UPS and returns the
requested data if it is available.

The format for requests from the CLIENT is documented in the <<protocol,TCP protocol>> section

Instant commands
~~~~~~~~~~~~~~~~

Instant commands is the term given to a set of actions that result in
something happening to the UPS.  Some of the common ones are
test.battery.start to initiate a battery test and test.panel.start to
test the front panel of the UPS.

They are passed to the SERVER from a CLIENT using an authenticated
network connection.  The SERVER first checks to make sure that the instant
command is valid for the DRIVER.  If it's supported, a message is sent 
via a socket to the DRIVER containing the command and any auxiliary
information.

At this point, there is no confirmation to the SERVER of the command's
execution.  This is (still) planned for a future release.  This has been
delayed since returning a response involves some potentially interesting
timing issues.  Remember that upsd services clients in a round-robin
fashion, so all queries must be lightweight and speedy.

Setting variables
~~~~~~~~~~~~~~~~~

Some variables in the DRIVER or EQUIPMENT can be changed, and carry the
FLAG_RW flag.  Upon receiving a SET command from the CLIENT, the SERVER
first verifies that it is valid for that DRIVER in terms of writability
and data type.  If those checks pass, it then sends the SET command
through the socket, much like the instant command design.

The DRIVER is expected to commit the value to the EQUIPMENT and update
its internal representation of that variable.

Like the instant commands, there is currently no acknowledgement of the
command's completion from the DRIVER.  This, too, is planned for a future
release.

Example data path
~~~~~~~~~~~~~~~~~

Here's the path a piece of data might take through this architecture.
The event is a UPS going on battery, and the final result is a pager
delivering the alpha message to the admin.

1. EQUIPMENT reports on battery by setting flag in status register

2. DRIVER notices this flag and stores it in the ups.status variable as
   OB.  This update gets pushed out to any listeners via the sockets.

3. SERVER upsd sees activity on the socket, reads it, parses it, and 
   commits the new data to its local version of the status variable. 

4. CLIENT upsmon does a routine poll of SERVER for "ups.status" and
   gets "OB".

5. CLIENT upsmon then invokes its NOTIFYCMD which is upssched.

6. upssched starts up a daemon to handle a timer which will expire about
   30 seconds into the future.

7. 30 seconds later, the timer expires since the UPS is still on battery,
   and upssched calls the CMDSCRIPT upssched-cmd.

8. upssched-cmd parses the args and calls sendmail.

9. Avian carriers, smoke signals, SMTP, and some magic result in the
   message getting from the pager company's gateway to a transmitter
   and then to the admin's pager.

This scenario requires some configuration, obviously:

1. There's a UPS driver running.
   (Whatever applies for the hardware)

2. upsd has a valid UPS entry in ups.conf for this UPS.

	[myups]
		driver = upsdriver
		port = /dev/ttySx

3. upsd has a valid user for upsmon in upsd.users.

	[monuser]
		password = somepass
		upsmon master

4. upsmon is set to monitor this UPS in upsmon.conf.
   
	MONITOR myups@localhost 1 monuser somepass master

5. upsmon is set to EXEC the NOTIFYCMD for the ONBATT condition in
   upsmon.conf.

	NOTIFYFLAG ONBATT EXEC

6. upsmon calls upssched as the NOTIFYCMD in upsmon.conf.

	NOTIFYCMD /path/to/upssched

7. upssched has a 30 second timer for ONBATT in upssched.conf.

	AT ONBATT * START-TIMER upsonbatt 30

8. upssched calls upssched-cmd as the CMDSCRIPT in upssched.conf.

	CMDSCRIPT /path/to/upssched-cmd

9. upssched-cmd knows what to do with "upsonbatt" as its first argument
   (A quick case..esac construct, see the examples)

History
~~~~~~~

The oldest versions of this software (1998) had no separation between
the driver and the network server and only supported the latest APC
Smart-UPS hardware as a result.  The network protocol used brittle
binary structs.  This had numerous bad implications for compatibility
and portability.

After the driver and server were separated, data was shared through the
state file concept.  Status was written into a static array (the "info
array") by drivers, and that array was stored on disk.  upsd would
periodically read that file into a local copy of that array.

Shared memory mode was added a bit later, and that removed some of the
lag from the status updates.  Unfortunately, it didn't have any locking
originally, and the possibility for corruption due to races existed.

mmap() support was added at some point after that, and became the
default.  The drivers and upsd would mmap() the file into memory and
read or write from it.  Locking was done using the state file as the
token, so contention problems were avoided.  This method was relatively
quick, but it involved at least 3 copies of the data (driver, disk/mmap,
server) and a whole lot of locking and unlocking.  It could occasionally
delay the driver or server when waiting for a lock.

In April 2003, the entire state management subsystem was removed and
replaced with a single local socket.  The drivers listen for
connections and push updates asynchronously to any listeners.  They also
recognize a few commands.  Drivers also dampen updates, and only push
them out when something actually changes.

As a result, upsd no longer has to poll any files on the disk, and can
just select() all of its fds and wait for activity.  When one of them is
active, it reads the fd and parses the results.  Updates from the
hardware now get to upsd about as fast as they possibly can.

Drivers used to call setinfo() to change the local array, and then would
call writeinfo() to push the array onto the disk, or into the 
mmap/shared memory space.  This introduced a lag since many drivers poll
quite a few variables during an update.

Information for developers
--------------------------

This section is intended to explain some of the more useful things
within the tree and provide a standard for working on the code.

General stuff - common subdirectory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

String handling
^^^^^^^^^^^^^^^

Use snprintf.  It's even provided with a compatibility module if the
target host doesn't have it natively.  

If you use snprintf to load some value into a buffer, make sure you
provide the format string.  Don't use user-provided format strings,
since that's an easy way to open yourself up to an exploit.

Don't use strcat.  We have a neat wrapper for snprintf called snprintfcat
that allows you to append to char * with a format string and all the usual
string length checking of snprintf.

Error reporting
^^^^^^^^^^^^^^^

Don't call syslog() directly.  Use upslog_with_errno() and upslogx().
They may write to the syslog, stderr, or both as appropriate.  This
means you don't have to worry about whether you're running in the
background or not.

upslog_with_errno prints your message plus the string expansion of
errno.  upslogx just prints the message.

fatal_with_errno and fatalx work the same way, but they
exit(EXIT_FAILURE) afterwards. Don't call exit() directly.

Debugging information
^^^^^^^^^^^^^^^^^^^^^

upsdebug_with_errno(), upsdebugx() and upsdebug_hex() use the
global nut_debug_level so you don't have to mess around with
printfs yourself.  Use them.

Memory allocation
^^^^^^^^^^^^^^^^^

xmalloc, xcalloc, xrealloc and xstrdup all check the results of the base
calls before continuing, so you don't have to.  Don't use the raw calls
directly.

Config file parsing
^^^^^^^^^^^^^^^^^^^

The configuration parser, called parseconf, is now up to its fourth
major version.  It has multiple entry points, and can handle many
different jobs.  It's usually used for parsing files, but it can also
take input a line at a time or even a character at a time.

You must initialize a context buffer with pconf_init before using any
other parseconf function.  pconf_encode is the only exception, since it
operates on a buffer you supply and is an auxiliary function.

Escaping special characters and quoting multiple-word elements is all
handled by the state machine.  Using the same code for all config files
avoids code duplication.

NOTE: this does not apply to drivers.  Driver authors should use the
upsdrv_makevartable() scheme to pick up values from ups.conf.  Drivers
should not have their own config files.

Drivers may have their own data files, such as lists of hardware,
mapping tables, or similar.  The difference between a data file and a
config file is that users should never be expected to edit a data file
under normal circumstances.  This technique might be used to add more
hardware support to a driver without recompiling.

<time.h> vs. <sys/time.h>
^^^^^^^^^^^^^^^^^^^^^^^^^

This is already handled by autoconf, so just include "timehead.h" and you
will get the right headers on every system.

UPS drivers - main.c
~~~~~~~~~~~~~~~~~~~~

The UPS drivers use main.c as their core.  The only exception is
dummycons, which only looks like a driver by using the same dstate
function calls.

To write a new driver, you create a file with a series of support
functions that will be called by main.  These all have names that start
with "upsdrv_", and they will be called at different times by main
depending on what needs to happen.

See the <<new-drivers,driver documentation>> for information on writing drivers, and also refer
to the skeletal driver in skel.c.

Portability
~~~~~~~~~~~

Avoid things that will break on other systems.  All the world is not an
x86 Linux box.

There are still older systems out there that don't do C++ style comments.

--------------------------------------
/* Comments look like this. */
// Not like this.
--------------------------------------

Newer versions of gcc allow you to declare a variable inside a function
somewhat like the way C++ operates, like this:

--------------------------------------
function do_stuff(void)
{
	check_something();

	int a; /* Danger! */

	a = do_something_else();
}
--------------------------------------

While this will compile and run on these newer versions, it will fail
miserably for anyone on an older system.  That means you must not use
it.  gcc only warns about this with -pedantic.

Coding style
~~~~~~~~~~~~

This is how we do things.

--------------------------------------
int open_subspace(char *ship, int privacy)
{
	if (!privacy)
		return insecure_channel(ship);
	
	if (!init_privacy(ship))
		fatal_with_errno("Can't open secure channel");

	return secure_channel(ship);
}
--------------------------------------

The basic idea is that we try to group things into functions, and then
find ways to drop out of them when we can't go any further.  There's
another way to program this involving a big else chunk and a bunch of
braces, and it can be hard to follow.  You can read this from top to
bottom and have a pretty good idea of what's going on without having to
track too much { } nesting and indenting.

We don't really care for pretentiousVariableNamingSchemes.  If your function or
variable names start pushing important code off the right margin of the screen,
expect them to meet the byte chainsaw sooner or later.

All types defined with typedef should end in "_t", because this is
easier to read, and it enables tools (such as indent and emacs) to
display the source code correctly.

Indenting with tabs vs. spaces
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Another thing to notice is that the indenting happens with tabs instead
of spaces.  This lets everyone have their personal tab-width setting
without inflicting much pain on other developers.  If you use a space,
then you've fixed the spacing in stone and have really annoyed half of
the people out there.

If you write something that uses spaces, you may get away with it in a
driver that's relatively secluded.  However, if I have to work on that
code, expect it to get reformatted according to the above.

Patches to existing code that don't conform to the coding style being
used in that file will probably be dropped.  If it's something we really
need, it will be grudgingly reformatted before being included.

When in doubt, have a look at Linus's take on this topic in the Linux
kernel - Documentation/CodingStyle.  He's done a far better job of
explaining this.

Line breaks
^^^^^^^^^^^

It is better to have lines that are longer than 80 characters than to
wrap lines in random places. This makes it easier to work with tools
such as "grep", and it also lets each developer choose their own
window size and tab setting without being stuck to one particular
choice.

Of course, this does not mean that lines should be made unnecessarily
long when there is a better alternative (see the note on
pretentiousVariableNamingSchemes above).  Certainly there should not
be more than one statement per line. Please do not use

	if (condition) break;

but use the following:

--------------------------------------
if (condition) {
	break;
}
--------------------------------------

Miscellaneous coding style tools
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You can go a long way towards converting your source code to the NUT
coding style by piping it through the following command:

--------------------------------------
indent -kr -i8 -T FILE -l1000 -nhnl
--------------------------------------

This next command does a reasonable job of converting most C++ style
comments (but not URLs and DOCTYPE strings):

--------------------------------------
sed 's#\(^\|[ \t]\)//[ \t]*\(.*\)[ \t]*#/* \2 */#'
--------------------------------------
 
Emacs users can adjust how tabs are displayed. For example, it is
possible to set a tab stop to be 3 spaces, rather than the usual 8.
(Note that in the saved file, one indentation level will still
correspond to one tab stop; the difference is only how the file is
rendered on screen). It is even possible to set this on a
per-directory basis, by putting something like this into your .emacs
file:

--------------------------------------
;; NUT style

(defun nut-c-mode ()
 "C mode with adjusted defaults for use with the NUT sources."
 (interactive)
 (c-mode)
 (c-set-style "K&R")
 (setq c-basic-offset 3)  ;; 3 spaces C-indentation
 (setq tab-width 3))      ;; 3 spaces per tab

;; apply NUT style to all C source files in all subdirectories of nut/

(setq auto-mode-alist (cons '(".*/nut/.*\\.[ch]$". nut-c-mode)
                       auto-mode-alist))
--------------------------------------

Finishing touches
^^^^^^^^^^^^^^^^^

I like code that uses const and static liberally.  If you don't need to
expose a function or global variable to the outside world, static is
your friend.  If nobody should edit the contents of some buffer that's
behind a pointer, const keeps them honest.

We always compile with -Wall, so things like const and static help you
find implementation flaws.  Functions that attempt to modify a constant
or access something outside their scope will throw a warning or even
fail to compile in some cases.  This is what we want.

//////////////////////////////////////////
Spaghetti
^^^^^^^^^

If you use a goto, expect me to drop it when my head stops spinning.
It gives me flashbacks to the BASIC code I wrote on the 8 bit systems of
the 80s.  I've tried to clean up my act, and you should make the effort
as well.  

I'm not making a blanket statement about gotos, since everything
probably has at least one good use.  There are a few cases where a goto
is more efficient than any other approach, but you probably won't
encounter them in this software.

Hint: there *was* a good use of a goto in upsd until the 1.3 series.  At
this point we are back to zero gotos since that code was replaced by
another technique that doesn't need it.
//////////////////////////////////////////

Legacy code
^^^^^^^^^^^

There are parts of the source tree that do not yet conform to these
specs.  Part of this is due to the fact that the coding style has been
evolving slightly over the course of the project.  Some of the code you
see in these directories is 5 years old, and things have gotten cleaner
since then.  Don't worry - it'll get cleaned up the next time something
in the vicinity gets a visit.

Memory leak checking
^^^^^^^^^^^^^^^^^^^^

I can't say enough good things about valgrind.  If you do anything with
dynamic memory in your code, you need to use this.  Just compile with -g
and start the program inside valgrind.  Run it through the suspected
area and then exit cleanly.  valgrind will tell you if you've done
anything dodgy like freeing regions twice, reading uninitialized memory,
or if you've leaked memory anywhere.

http://valgrind.kde.org/[]

Conclusion
^^^^^^^^^^

The summary: please be kind to my eyes.  There's a lot of stuff in here.

Submitting patches
~~~~~~~~~~~~~~~~~~

Patches that arrive in unified format (diff -u) as plain text with no
HTML, no attachments and a brief summary at the top are the easiest to
handle. They show the context, explain what's going on, and get saved as
one message.  Everything stays together until it's time to merge.

Patches that arrive as attachments have to be moved around as separate
files - the body of the message is one, and the patch is in another.
This is not my preferred mode of operation.

When sending patches to the lists, be sure to add me as an explicit
recipient to make sure it is considered for merging.  A patch which only
goes to a list is generally treated as a RFC and is relatively low
priority.

If your mailer is brain dead and rewrites tabs into spaces, wraps your
patch body, or anything else like that, just attach the patch.  I'd
rather deal with an attachment instead of a patch that has tab damage,
rewrapped lines, or worse.

Patch cohesion
~~~~~~~~~~~~~~

Patches should have some kind of unifying element.  One patch set is one
message, and it should all touch similar things.  If you have to edit 6
files to add support for neutrino detection in UPS hardware, that's
fine.

However, sending one huge patch that does massive separate changes
all over the tree is not recommended.  That kind of patch has to be
split up and evaluated separately, assuming I care enough to do that
instead of just dropping it.

If you have to make big changes in lots of places, send multiple
patches - one per item.

Man pages
~~~~~~~~~

If you change something that involves an argument to a program or
configuration file parsing, the man page is probably now out of date.
If you don't update it, I have to, and I have enough to do as it is.

If you write a new driver, send in the man page when you send me the
source code for your driver.  Otherwise, I will be forced to write a
skeletal man page that will probably miss many of the finer points of
the driver and hardware.

Repository etiquette and quality assurance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Please keep the SVN trunk in working condition at all times. The trunk
may be used to generate daily tarballs, and should not contain broken
code if possible. If you need to commit incremental changes that leave
the system in a broken state, please do so in a separate branch and
merge the changes back to the trunk once they are complete.

Before committing, please remember to:

* update the ChangeLog, if appropriate. Dates are listed in UTC 
  ("date --utc").

* run "make distcheck-light". This checks that the Makefiles are not
  broken, that all the relevant files are distributed, and that there
  are no compilation or installation errors.

Running "make distcheck-light" is especially important if you have
added or removed files, or updated configure.in or some Makefile.am.
Remember: simply adding a file to SVN does not mean it will be
distributed. To distribute a file, you must update the corresponding
Makefile.am.

There is also "make distcheck", which runs an even stricter set of
tests, but will not work unless you have all the optional libraries
and features installed.


[[commands]]
Commands sent to the UPS drivers
--------------------------------

upsd can call drivers to store values in read/write variables and to kick
off instant commands.  This is how you register handlers for those events.

The driver core (drivers/main.c) has a structure called upsh.  You
should populate it with function pointers in your upsdrv_initinfo()
function.  Right now, there are only two possibilities:

- setvar  = setting UPS variables (SET VAR protocol command)
- instcmd = instant UPS commands (INSTCMD protocol command)

SET
~~~

If your driver's function for handling variable set events is called 
my_ups_set(), then you'd do this to add the pointer:

	upsh.setvar = my_ups_set;

my_ups_set() will receive two parameters:

	const char * - the variable being changed
	const char * - the new value

You should return either STAT_SET_HANDLED if your driver recognizes the
command, or STAT_SET_UNKNOWN if it doesn't.  Other possibilities will be
added at some point in the future.

INSTCMD
~~~~~~~

This works just like the set process, with slightly different values
arriving from the server.

	upsh.instcmd = my_ups_cmd;

Your function will receive two args:

	const char * - the command name
	const char * - (reserved)

You should return either STAT_INSTCMD_HANDLED or STAT_INSTCMD_UNKNOWN
depending on whether your driver can handle the requested command.

Notes
~~~~~

Use strcasecmp.  The command names arriving from upsd should be treated
without regards to case.

Responses
~~~~~~~~~

Drivers will eventually be expected to send responses to commands.
Right now, there is no channel to get these back through upsd to
the client, so this is not implemented.

This will probably be implemented with a polling scheme in the clients.

[[new-drivers]]
Creating a new driver to support another UPS
---------------------------------------------

*Comment*
start by an intro on generic drivers?

- extending drivers
- Basic serial
- USB
- SNMP
- ... fenton, megatec=> blazer, ...

add sub notes on(?):
- outlet collection implementation
- ...whatever more has to be known

Smart vs. Contact-closure
~~~~~~~~~~~~~~~~~~~~~~~~~

NOTE: add link to contact-closure.txt

If your UPS only does contact closure readings, then go straight to the
contact-closure.txt document for information on adding support.  It's a
lot easier to add a few lines to a header file than it is to create a
whole new driver.

Serial vs. USB vs. SNMP and more
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your UPS connects to your computer via a USB port, then go straight
to the document hid-subdrivers.txt. You can probably add support for
your device by writing a new subdriver to the existing usbhid-ups
driver, which is easier than writing an entire new driver.

Similarly, if your UPS connects to your computer via an SNMP network
card, you can probably add support for your device by writing a new
subdriver to the existing snmp-ups driver, which is easier than writing
an entire new driver.

Overall concept
~~~~~~~~~~~~~~~

The basic design of drivers is simple.  main.c handles most of the work
for you.  You don't have to worry about arguments, config files, or
anything else like that.  Your only concern is talking to the hardware
and providing data to the outside world.

Skeleton driver
~~~~~~~~~~~~~~~

Familiarize yourself with the design of skel.c in the drivers directory.
It shows a few examples of the functions that main will call to obtain
updated information from the hardware.

Essential structure
~~~~~~~~~~~~~~~~~~~

upsdrv_info_t
^^^^^^^^^^^^^

This structure tracks several description information about the driver:

 * name: the driver full name, for banner printing.
 * version: the driver's own version. For sub driver information, refer below
            to sub_upsdrv_info. This value has the form "X.YZ", and is
            published by main as "driver.version.internal".
 * authors: the driver's author(s) name. If multiple authors are listed, separate
            them with a newline character so that it can be broken up by author if needed.
 * status: the driver development status. The following values are allowed:
           - DRV_BROKEN: setting this value will cause main to print an error
             and exit. This is only used during conversions of the driver core
             to keep users from using drivers which have not been converted.
             Drivers in this state will be removed from the tree after some
             period if they are not fixed.
           - DRV_EXPERIMENTAL: set this value if your driver is potentially
             broken. This will trigger a warning when it starts so the user
             doesn't take it for granted.
           - DRV_BETA: this value means that the driver is more stable and
             complete. But it is still not recommended for production systems.
           - DRV_STABLE: the driver is suitable for production systems, but not
             100 % feature complete.
           - DRV_COMPLETE: this is the gold level! It implies that 100 % of the
             protocol is implemented, and a full QA pass.
 * subdrv_info: array of upsdrv_info_t for sub driver(s) information. For
   example, this is used by usbhid-ups and megatec.

This information is currently used for the startup banner printing and tests.

Essential functions
~~~~~~~~~~~~~~~~~~~

upsdrv_initups
^^^^^^^^^^^^^^

Open the port (device_path) and do any low-level things that it may need
to start using that port.  If you have to set DTR or RTS on a serial
port, do it here.

Don't do any sort of hardware detection here, since you may be going
into upsdrv_shutdown next.

upsdrv_initinfo
^^^^^^^^^^^^^^^

Try to detect what kind of UPS is out there, if any, assuming that's
possible for your hardware.  If there is a way to detect that hardware
and it doesn't appear to be connected, display an error and exit. This
is the last time your driver is allowed to bail out.

This is usually a good place to create variables like ups.mfr,
ups.model, ups.serial, and other "one time only" items.

upsdrv_updateinfo
^^^^^^^^^^^^^^^^^

Poll the hardware, and update any variables that you care about
monitoring.  Use dstate_setinfo() to store the new values.

Do at most one pass of the variables.  You MUST return from this
function or upsd will be unable to read data from your driver.  main
will call this function at regular intervals.

Don't spent more than a couple of seconds in this function. Typically
five (5) seconds is the maximum time allowed before you risk that the
server declares the driver stale. If your UPS hardware requires a
timeout period of several seconds before it answers, consider returning
from this function after sending a command immediately and read the
answer the next time it is called.

You must never abort from upsdrv_updateinfo(), even when the UPS doesn't
seem to be attached anymore. If the connection with the UPS is lost, the
driver should retry to re-establish communication for as long as it is
running. Calling exit() or any of the fatal*() functions is specifically
not allowed anymore.

upsdrv_shutdown
~~~~~~~~~~~~~~~

Do whatever you can to make the UPS power off the load but also return
after the power comes back on.  You may use a different command that
keeps the UPS off if the user has requested that with a configuration
setting.

You should attempt the UPS shutdown command even if the UPS detection
fails.  If the UPS does not shut down the load, then the user is
vulnerable to a race if the power comes back on during the shutdown
process.

Data types
~~~~~~~~~~

To be of any use, you must supply data in ups.status.  That is the
minimum needed to let upsmon do its job.  Whenever possible, you should
also provide anything else that can be monitored by the driver.  Some
obvious things are the manufacturer name and model name, voltage data,
and so on.

If you can't figure out some value automatically, use the ups.conf
options to let the user tell you.  This can be useful when a driver
needs to support many similar hardware models but can't probe to see
what is actually attached.

Manipulating the data
~~~~~~~~~~~~~~~~~~~~~

All status data lives in structures that are managed by the dstate
functions.  All access and modifications must happen through those
functions.  Any other changes are forbidden, as they will not pushed out
as updates to things like upsd.

Adding variables
^^^^^^^^^^^^^^^^

	dstate_setinfo("ups.model", "Mega-Zapper 1500");

Many of these functions take format strings, so you can build the new
values right there:

	dstate_setinfo("ups.model", "Mega-Zapper %d", rating);

Setting flags
^^^^^^^^^^^^^

Some variables have special properties.  They can be writable, and some
are strings.  The ST_FLAG_* values can be used to tell upsd more about
what it can do.

	dstate_setflags("input.transfer.high", ST_FLAG_RW);

Status data
^^^^^^^^^^^

UPS status flags like on line (OL) and on battery (OB) live in
ups.status.  Don't manipulate this by hand.  There are functions which
will do this for you.

        status_init() - before doing anything else

        status_set(val) - add a status word (OB, OL, etc)

        status_commit() - push out the update

Possible values for status_set:

 OL      - On line (mains is present)
 OB      - On battery (mains is not present)
 LB      - Low battery
 RB      - The battery needs to be replaced
 CHRG    - The battery is charging
 DISCHRG - The battery is discharging (inverter is providing load power)
 BYPASS  - UPS bypass circuit is active - no battery protection is available
 CAL     - UPS is currently performing runtime calibration (on battery)
 OFF     - UPS is offline and is not supplying power to the load
 OVER    - UPS is overloaded
 TRIM    - UPS is trimming incoming voltage (called "buck" in some hardware)
 BOOST   - UPS is boosting incoming voltage

Anything else will not be recognized by the usual clients.  Coordinate
with the nut-upsdev list before creating something new, since there will be duplication
and ugliness otherwise.

NOTE: upsd injects "FSD" by itself following that command by a master
upsmon process.  Drivers must not set that value.

NOTE: the OL and OB flags are an indication of the input line status only.

UPS alarms
~~~~~~~~~~

These work like ups.status, and have three special functions which you
must use to manage them.

	alarm_init() - before doing anything else

	alarm_set() - add an alarm word

	alarm_commit() - push the value into ups.alarm

NOTE: the ALARM flag in ups.status is automatically set whenever you use
alarm_set.  To remove that flag from ups.status, call alarm_init and
alarm_commit without calling alarm_set in the middle.

You should never try to set or unset the ALARM flag manually.

If you use UPS alarms, the call to status_commit() should be after
alarm_commit(), otherwise there will be a delay in setting the ALARM
flag in ups.status.

There is no official list of alarm words as of this writing, so don't
use these functions until you check with the upsdev list.

Staleness control
~~~~~~~~~~~~~~~~~

If you're not talking to a polled UPS, then you must ensure that it
is still out there and is alive before calling dstate_dataok().  Even
if nothing is changing, you should still "ping" it or do something
else to ensure that it is really available.  If the attempts to
contact the UPS fail, you must call dstate_datastale() to inform the
server and clients.

 - dstate_dataok() 

   You must call this if polls are succeeding.  A good place to call this
   is the bottom of upsdrv_updateinfo().

 - dstate_datastale()

   You must call this if your status is unusable.  A good technique is
   to call this before exiting prematurely from upsdrv_updateinfo().

Don't hide calls to these functions deep inside helper functions.  It is
very hard to find the origin of staleness warnings, if you call these from
various places in your code.  Basically, don't call them from any other
function than from within upsdrv_updateinfo().  There is no need to call
either of these regularly as was stated in previous versions of this
document (that requirement has long gone).

Serial port handling
~~~~~~~~~~~~~~~~~~~~

Drivers which use serial port functions should include serial.h and use
these functions whenever possible:


 - int ser_open(const char *port)

This opens the port and locks it if possible, using one of fcntl, lockf,
or uu_lock depending on what may be available.  If something fails, it
calls fatal for you.  If it succeeds, it always returns the fd that was
opened.


 - int ser_set_speed(int fd, const char *port, speed_t speed)

This sets the speed of the port and also does some basic configuring
with tcgetattr and tcsetattr.  If you have a special serial
configuration (other than 8N1), then this may not be what you want.

The port name is provided again here so failures in tcgetattr() provide
a useful error message.  This is the only place that will generate a
message if someone passes a non-serial port /dev entry to your driver,
so it needs the extra detail.


 - int ser_set_dtr(int fd, int state)
 - int ser_set_rts(int fd, int state)

These functions can be used to set the modem control lines to provide
cable power on the RS232 interface. Use state = 0 to set the line to 0
and any other value to set it to 1.


 - int set_get_dsr(int fd)
 - int ser_get_cts(int fd)
 - int set_get_dcd(int fd)

These functions read the state of the modem control lines. They will
return 0 if the line is logic 0 and a non-zero value if the line is
logic 1.


 - int ser_close(int fd, const char *port)

This function unlocks the port if possible and closes the fd.  You
should call this in your upsdrv_cleanup handler.


 - int ser_send_char(int fd, char ch)

This attempts to write one character and returns the return value from
write.  You could call write directly, but using this function allows
for future error handling in one place.


 - int ser_send_pace(int fd, unsigned long d_usec, 
	const char *fmt, ...)

If you need to send a formatted buffer with an intercharacter delay, use
this function.  There are a number of UPS controllers which can't take
commands at the full speed that would normally be possible at a given
bit rate.  Adding a small delay usually turns a flaky UPS into a solid
one.

The return value is the number of characters that was sent to the port,
or -1 if something failed.


 - int ser_send(int fd, const char *fmt, ...)

Like ser_send_pace, but without a delay.  Only use this if you're sure
that your UPS can handle characters at the full line rate.


 - int ser_send_buf(int fd, const char *buf, size_t buflen)

This sends a raw buffer to the fd.  It is typically used for binary
transmissions.  It returns the results of the call to write.


 - int ser_send_buf_pace(int fd, unsigned long d_usec, const char *buf, 
	size_t buflen)

This is just ser_send_buf with an intercharacter delay.


 - int ser_get_char(int fd, char *ch, long d_sec, long d_usec)

This will wait up to d_sec seconds + d_usec microseconds for one
character to arrive, storing it at ch.  It returns 1 on success, -1
if something fails and 0 on a timeout.

NOTE: the delay value must not be too large, or your driver will not get
back to the usual idle loop in main in time to answer the PINGs from
upsd.  That will cause an oscillation between staleness and normal
behavior.


 - int ser_get_buf(int fd, char *buf, size_t buflen, long d_sec,
	long d_usec)

Like ser_get_char, but this one reads up to buflen bytes storing all of
them in buf.  The buffer is zeroed regardless of success or failure.  It
returns the number of bytes read, -1 on failure and 0 on a timeout.

This is essentially a single read() function with a timeout.


 - int ser_get_buf_len(int fd, char *buf, size_t buflen, long d_sec,
	long d_usec)

Like ser_get_buf, but this one waits for buflen bytes to arrive,
storing all of them in buf.  The buffer is zeroed regardless of success
or failure.  It returns the number of bytes read, -1 on failure
and 0 on a timeout.

This should only be used for binary reads.  See ser_get_line for
protocols that are terminated by characters like CR or LF.


 - int ser_get_line(int fd, char *buf, size_t buflen, char endchar,
	const char *ignset, long d_sec, long d_usec)

This is the reading function you should use if your UPS tends to send
responses like "OK\r" or "1234\n".  It reads up to buflen bytes and
stores them in buf, but it will return immediately if it encounters
endchar.  The endchar will not be stored in the buffer.  It will also
return if it manages to collect a full buffer before reaching the
endchar.  It returns the number of bytes stored in the buffer, -1 on
failure and 0 on a timeout.

If the character matches the ignset with strchr(), it will not be added
to the buffer.  If you don't need to ignore any characters, just pass it
an empty string - "".

The buffer is always cleared and is always null-terminated.  It does
this by reading at most (buflen - 1) bytes.

NOTE: any other data which is read after the endchar in the serial
buffer will be lost forever.  As a result, you should not use this 
unless your UPS uses a polled protocol.

Let's say your endchar is \n and your UPS sends "OK\n1234\nabcd\n".
This function will read() all of that, find the first \n, and stop
there.  Your driver will get "OK", and the rest is gone forever.

This also means that you should not "pipeline" commands to the UPS.
Send a query, then read the response, then send the next query.


 - int ser_get_line_alert(int fd, char *buf, size_t buflen, 
	char endchar, const char *ignset, const char *alertset, 
	void handler(char ch), long d_sec, long d_usec)

This is just like ser_get_line, but it allows you to specify a set of
alert characters which may be received at any time.  They are not added
to the buffer, and this function will call your handler function,
passing the character as an argument.

Implementation note: this function actually does all of the work, and
ser_get_line is just a wrapper that sets an empty alertset and a NULL
handler.


 - int ser_flush_in(int fd, const char *ignset, int verbose)

This function will drain the input buffer.  If verbose is set to a
positive number, then it will announce the characters which have been
read in the syslog.  You should not set verbose unless debugging is
enabled, since it could be very noisy.

This function returns the number of characters which were read, so you
can check for extra bytes by looking for a nonzero return value.  Zero
will also be returned if the read fails for some reason.


 - int set_flush_io(int fd)

This function drains both the in- and output buffers. Return zero on
success.


 - void ser_comm_fail(const char *fmt, ...)

Call this whenever your serial communications fail for some reason.  It
takes a format string, so you can use variables and other things to
clarify the error.  This function does built-in rate-limiting so you
can't spam the syslog.

By default, it will write 10 messages, then it will stop and only write
1 in 100.  This allows the driver to keep calling this function while
the problem persists without filling the logs too quickly.

In the old days, drivers would report a failure once, and then would be
silent until things were fixed again.  Users had to figure out what was
happening by finding that single error message, or by looking at the
repeated complaints from upsd or the clients.

If your UPS frequently fails to acknowledge polls and this is a known
situation, you should make a couple of attempts before calling this
function.

NOTE: this does not call dstate_datastale.  You still need to do that.


 - void ser_comm_good(void)

This will clear the error counter and write a "re-established" message
to the syslog after communications have been lost.  Your driver should
call this whenever it has successfully contacted the UPS.  A good place
for most drivers is where it calls dstate_dataok.

USB port handling
~~~~~~~~~~~~~~~~~

Drivers which use USB functions should include usb-common.h and use these:

 * structure and macro:
 
   You should us the usb_device_id structure, and the USB_DEVICE macro to
   declare the supported devices. This allows the automatic extraction of
   USB information, to generate the HAL, Hotplug and udev support files.

   For example:
   /* SomeVendor name */
   #define SOMEVENDOR_VENDORID		0xXXXX

   /* USB IDs device table */
   static usb_device_id sv_usb_device_table [] = {
	 /* some models 1 */
	 { USB_DEVICE(SOMEVENDOR_VENDORID, 0xYYYY), NULL },
	 /* various models */
	 { USB_DEVICE(SOMEVENDOR_VENDORID, 0xZZZZ), NULL },
	 { USB_DEVICE(SOMEVENDOR_VENDORID, 0xAAAA), NULL },
	 /* Terminating entry */
	 { -1, -1, NULL }
   };

 * function:

 - is_usb_device_supported(usb_device_id **usb_device_id_list, 
							int dev_VendorID, int dev_ProductID)

Call this in your device opening / matching function. Pass your usb_device_id
structure, and a set of VendorID / DeviceID.

This function returns one of the following value: 
NOT_SUPPORTED (0), POSSIBLY_SUPPORTED (1) or SUPPORTED (2) 
POSSIBLY_SUPPORTED is returned when the VendorID is matched, but the DeviceID
is unknown.

For implementation examples, refer to the various USB drivers, and search for
the above patterns.


This set of USB helpers is due to expand is the near future...

Variable names
~~~~~~~~~~~~~~

PLEASE don't make up new variables and commands just because you can.
The new dstate functions give us the power to create just about
anything, but that is a privilege and not a right.  Imagine the mess
that would happen if every developer decided on their own way to
represent a common status element.

Check the <<new-names,Command Names>> section first to find the closest fit.  If nothing matches,
contact the upsdev list or mail me directly, and we'll figure it out.

Patches which introduce unlisted names may be modified or dropped.

Message passing support
~~~~~~~~~~~~~~~~~~~~~~~

See the <<commands>> section.

Enumerated types
~~~~~~~~~~~~~~~~

If you have a variable that can have several specific values, it is
enumerated.  You should add each one to make it available to the client:

	dstate_addenum("input.transfer.low", "92");
	dstate_addenum("input.transfer.low", "95");
	dstate_addenum("input.transfer.low", "99");
	dstate_addenum("input.transfer.low", "105");

Writable strings
~~~~~~~~~~~~~~~~

Strings that may be changed by the client should have the ST_FLAG_STRING
flag set, and a maximum length byte set in the auxdata.

	dstate_setinfo("ups.id", "Big UPS");
	dstate_setflags("ups.id", ST_FLAG_STRING | ST_FLAG_RW);
	dstate_setaux("ups.id", 8);

If the variable is not writable, don't bother with the flags or the
auxiliary data.  It won't be used.

Instant commands
~~~~~~~~~~~~~~~~

If your hardware and driver can support a command, register it.

	dstate_addcmd("load.on");

Delays and ser_* functions
~~~~~~~~~~~~~~~~~~~~~~~~~~

The new ser_* functions may perform reads faster than the UPS is able to
respond in some cases.  This means that your driver will call select()
and read() numerous times if your UPS responds in bursts.  This also
depends on how fast your system is.

You should check your driver with strace or its equivalent on your
system.  If the driver is calling read() multiple times, consider adding
a call to usleep before going into the ser_read_* call.  That will give
it a chance to accumulate so you get the whole thing with one call to
read without looping back for more.

This is not a request to save CPU time, even though it may do that.  The
important part here is making the strace/ktrace output easier to read.

	write(4, "Q1\r", 3)                     = 3
	nanosleep({0, 300000000}, NULL)         = 0
	select(5, [4], NULL, NULL, {3, 0})      = 1 (in [4], left {3, 0})
	read(4, "(120.0 084.0 120.0   0 60.0 22.6"..., 64) = 47

Without that delay, that turns into a mess of selects and reads.
The select returns almost instantly, and read gets a tiny chunk of the
data.  Add the delay and you get a nice four-line status poll.

Canonical input mode processing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If your UPS uses "\n" and/or "\r" as endchar, consider the use of
Canonical Input Mode Processing instead of the ser_get_line* functions.

Using a serial port in this mode means that select() will wait until
a full line is received (or times out). This relieves you from waiting
between sending a command and reading the reply. Another benefit is,
that you no longer have to worry about the case that your UPS sends
"OK\n1234\nabcd\n". This will be broken up cleanly in "OK\n", "1234\n"
and "abcd\n" on consecutive reads, without risk of losing data (which
is an often forgotten side effect of the ser_get_line* functions).

Currently an example how this works can be found in the safenet and
upscode2 drivers. The first uses a single "\r" as endchar, while the
latter accepts either "\n", "\n\r" or "\r\n" as line termination. You
can define other termination characters as well, but can't undefine
"\r" and "\n" (so if you need these as data, this is not for you).

[[new-names]]
Command and variable naming scheme
----------------------------------

include new-names.txt

*Comment* this file should be renamed. it's not new anymore!

Creating new client
-------------------

*Comment* this content is to be created from scratch.

Intro idea: "NUT provides bindings, for several common languages, that are
presented below. If none suits you, you can implement one easily using the 
'Network protocol information'. This approach has been used to create the
Python PyNUT module and the Nagios check_ups plugin, which can serve as a
reference."

C / C++
~~~~~~~

Client access library
^^^^^^^^^^^^^^^^^^^^^
man/upsclient.3

Configuration helpers
^^^^^^^^^^^^^^^^^^^^^

NUT provides helper scripts to ease the configuration step of your program, by
detecting...

libupsclient-config.1
+ pkg-config

Python
~~~~~~

...
Comment: content from scripts/python/README
+ point scripts/python/module/test_nutclient.py

Perl
~~~~

Comment: The binding has to be tested and probably updated before we can
document it!
The content of this ยง is to be ripped from the http://search.cpan.org/dist/ups-nut/[UPS::Nut] module README:


[[protocol]]
Network protocol information
----------------------------

include protocol.txt

Ideas for future expansion and features (and improvement?)
----------------------------------------------------------

include ideas.txt

*Comments*

- check to refresh and integrate the https://alioth.debian.org/pm/?group_id=30602[tasks] list
and https://alioth.debian.org/tracker/?atid=411545&group_id=30602&func=browse[feature requests] list from Alioth
- add "Generic ?Ascii? driver": I've got to think more about that, but the recent
solar panel driver, and the powerman internal approach of a generic engine with
a scripting interface is a cool idea.
Ref http://powerman.svn.sourceforge.net/viewvc/powerman/trunk/etc/apcpdu.dev?revision=969&view=markup
- integrate the (future) new powerman LUA engine (maybe/mustbe used for the driver above?)
for native PDU support
- see how we can help and collaborate with DeviceKit-power



[[sock-protocol]]
Driver/server socket protocol
-----------------------------

include sock-protocol.txt
