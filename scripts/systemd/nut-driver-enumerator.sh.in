#!/bin/sh
#
# Copyright (C) 2016-2017 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    nut-driver-enumerator.sh(.in)
#  \author  Jim Klimov <EvgenyKlimov@eaton.com>
#  \brief   Enumerate NUT devices for service-unit instance configuration
#  \details This script allows to enumerate UPSes in order to produce the
#           individual service unit instances for each defined configuration.
#           It assumes the user has adequate permissions to inspect and create
#           services (e.g. is a root or has proper RBAC profiles to do so).
#           It helps service frameworks such as Linux systemd and Solaris SMF.
#           When executed, this script looks for all configured ups.conf
#           sections and registered service instances, and makes these two
#           lists match up. No arguments ATM. Returns exit codes:
#               0   Sections and services already match up
#               42  Sections and services differed, but now match up -
#                   now the caller should likely restart some services.
#                   Note that the drivers' service instances were started or
#                   stopped as required (by AUTO_START=yes) - but maybe the
#                   upsd or upsmon services should restart.
#               13  Sections and services differed, and still do not match up
#               1   Bad inputs, e.g. unrecognized service management framework
#               2   Absent or unreadable ups.conf file
#  \todo    Complete the sample basic support for Solaris SMF (needs support
#           for the service definitions similar to systemd NUT units to be
#           added to that platform first). Parts in this script are finished.
#

# Directory where NUT configs are located, e.g. /etc/nut or /etc/ups
# Set at package configuration, compiled into daemons and drivers
[ -n "${NUT_CONF_DIR-}" ] || NUT_CONF_DIR="@sysconfdir@"

# Third-party services to depend on (can be overridden by config file)
### Note that for systemd+udev integration, it may be better to set up
### triggers in udev, see e.g.
###   http://stackoverflow.com/questions/18463755/linux-start-daemon-on-connected-usb-serial-dongle
### Also can tune whether a driver "Wants" another service (would consider
### ordering if that one is enabled, but live if it is disabled), or if it
### "Requires" that (would cause that to start).
DEPSVC_USB_SYSTEMD="systemd-udev.service"
DEPREQ_USB_SYSTEMD="Wants"
DEPSVC_NET_FULL_SYSTEMD="network-online.target"
DEPREQ_NET_FULL_SYSTEMD="Wants"
DEPSVC_NET_LOCAL_SYSTEMD="network.target"
DEPREQ_NET_LOCAL_SYSTEMD="Wants"

# Some or all of these FMRIs may be related to dynamically changing hardware
#   require_all) ;; # All cited services are running (online or degraded)
#   require_any) ;; # At least one of the cited services is running
#   optional_all) ;; # (All) cited services are running or would not run
#                  # without administrative action (disabled, maintenance,
#                  # not present, or are waiting for dependencies which do
#                  # not start without administrative action).
DEPSVC_USB_SMF="svc:/system/hotplug:default svc:/system/dbus:default svc:/system/hal:default svc:/milestone/devices:default"
DEPREQ_USB_SMF="optional_all"
# By default there are several physical network FMRIs shipped and at most
# only one is enabled on a particular system (e.g. :default or :nwam)
DEPSVC_NET_FULL_SMF="svc:/network/physical"
DEPREQ_NET_FULL_SMF="optional_all"
DEPSVC_NET_LOCAL_SMF="svc:/network/loopback:default"
DEPREQ_NET_LOCAL_SMF="optional_all"

[ -z "${NUT_DRIVER_ENUMERATOR_CONF-}" ] && \
    NUT_DRIVER_ENUMERATOR_CONF="${NUT_CONF_DIR}/nut-driver-enumerator.conf"

[ -s "${NUT_DRIVER_ENUMERATOR_CONF}" ] && \
    echo "Sourcing config file: ${NUT_DRIVER_ENUMERATOR_CONF}" && \
    . "${NUT_DRIVER_ENUMERATOR_CONF}"

[ -z "${UPSCONF-}" ] && \
    UPSCONF="${NUT_CONF_DIR}/ups.conf"

# Start a freshly-registered unit?
[ -z "${AUTO_START-}" ] && AUTO_START=yes

if [ -z "${SERVICE_FRAMEWORK-}" ] ; then
    [ -x /usr/sbin/svcadm ] && [ -x /usr/sbin/svccfg ] && [ -x /usr/bin/svcs ] && \
        SERVICE_FRAMEWORK="smf"
    [ -z "${SERVICE_FRAMEWORK-}" ] && \
        [ -x /bin/systemctl ] && \
        SERVICE_FRAMEWORK="systemd"
fi

# Cache needed bits of ups.conf to speed up later parsing. Note that these
# data are needed for most operations, and populated by upslist_readFile()
UPSCONF_DATA=""

# List of configured UPSes in the config-file
UPSLIST_FILE=""
# List of configured service instances for UPS drivers
UPSLIST_SVCS=""
hook_registerInstance=""
hook_unregisterInstance=""
hook_listInstances=""

case "${SERVICE_FRAMEWORK-}" in
    smf)
        hook_registerInstance="smf_registerInstance"
        hook_unregisterInstance="smf_unregisterInstance"
        hook_listInstances="smf_listInstances"
        ;;
    systemd)
        hook_registerInstance="systemd_registerInstance"
        hook_unregisterInstance="systemd_unregisterInstance"
        hook_listInstances="systemd_listInstances"
        ;;
    "")
        echo "Error detecting the service-management framework on this OS" >&2
        exit 1
        ;;
    *)
        echo "Error: User provided an unknown service-management framework '$SERVICE_FRAMEWORK'" >&2
        exit 1
        ;;
esac

common_isFiled() {
    [ -n "$UPSLIST_FILE" ] && \
    for UPSF in $UPSLIST_FILE ; do
        [ "$1" = "$UPSF" ] && return 0
    done
    return 1
}

common_isRegistered() {
    [ -n "$UPSLIST_SVCS" ] && \
    for UPSS in $UPSLIST_SVCS ; do
        [ "$1" = "$UPSS" ] && return 0
    done
    return 1
}

upsconf_getValue() {
    # "$1" = name of ups.conf section; $2 = name of config key; echo the value
    [ -n "$1" ] || return $?
    [ -n "$2" ] || return $?
    CURR_SECTION=""
    echo "$UPSCONF_DATA" | \
    while read LINE ; do
        case "$LINE" in
            \["$1"\]) CURR_SECTION="$1" ;;
            \[*\])
                [ "$CURR_SECTION" = "$1" ] && break
                CURR_SECTION="other"
                ;;
            "$2"=*) if [ "$CURR_SECTION" = "$1" ]; then
#                    VALUE="$(echo "$LINE" | sed -e 's,\#.*$,,' -e 's,^[\t\ ]*,,' -e 's,[\t\ ]*$,,' -e 's,[\t\ ]*=[\t\ ]*,=,' -e 's,'"$2"'=\([^\t\ ]*\)[\t\ ]*.*$,\1,')"
                    VALUE="$(echo "$LINE" | sed -e 's,^'"$2"'=\([^\t\ ]*\)[\t\ ]*.*$,\1,')"
                    RES=$?
                    echo "$VALUE"
                    return $RES
                fi
                ;;
            *) ;;
        esac
    done
    # Nothing matched
    return 1
}

upsconf_getDriver() {
    # "$1" = name of ups.conf section; return (echo) the driver name used there
    # In the context this function is used, UPSCONF exists and section is there
    upsconf_getValue "$1" "driver"
    return $?
}

upsconf_getPort() {
    # "$1" = name of ups.conf section; return (echo) the "port" name used there
    # In the context this function is used, UPSCONF exists and section is there
    upsconf_getValue "$1" "port"
    return $?
}

upsconf_getDriverMedia() {
    # "$1" = name of ups.conf section; return (echo) name and type of driver as
    # needed for dependency evaluation (what services we must depend on for this
    # unit), newline-separated (drvname<EOL>type). Empty type for unclassified
    # results, assuming no known special dependencies (note that depending on
    # particular system's physics, both serial and network media may need USB).
    CURR_DRV="`upsconf_getDriver "$1"`" || return $?
    case "$CURR_DRV" in
        *netxml*|*snmp*|*ipmi*|*powerman*|*-mib*|*avahi*|*apcsmart*|*apcupsd*)
            printf '%s\n%s\n' "$CURR_DRV" "network" ; return ;;
        *usb*)
            printf '%s\n%s\n' "$CURR_DRV" "usb" ; return ;;
        *dummy*|*clone*) # May be networked (proxy to remote NUT)
            CURR_PORT="`upsconf_getPort "$1"`" || CURR_PORT=""
            case "$CURR_PORT" in
                *@localhost|*@|*@127.0.0.1|*@::1)
                    printf '%s\n%s\n' "$CURR_DRV" "network-localhost" ; return ;;
                *@*)
                    printf '%s\n%s\n' "$CURR_DRV" "network" ; return ;;
                *)
                    printf '%s\n%s\n' "$CURR_DRV" "" ; return ;;
            esac
            ;;
        *)  printf '%s\n%s\n' "$CURR_DRV" "" ; return ;;
    esac
}

upsconf_getMedia() {
    _DRVMED="`upsconf_getDriverMedia "$1"`" || return
    echo "$_DRVMED" | tail -n +2
    return 0
}

upsconf_debug() {
    _DRV="`upsconf_getDriver "$1"`"
    _PRT="`upsconf_getPort "$1"`"
    _MED="`upsconf_getMedia "$1"`"
    echo "INST: [$1]: DRV='$_DRV' PORT='$_PRT' MEDIA='$_MED'"
}

smf_registerInstance() {
    /usr/sbin/svccfg -s nut-driver add "$1" || return

    DEPSVC=""
    DEPREQ=""
    _MED="`upsconf_getMedia "$1"`"
    case "$_MED" in
        usb)
            DEPSVC="$DEPSVC_USB_SMF"
            DEPREQ="$DEPREQ_USB_SMF" ;;
        network-localhost)
            DEPSVC="$DEPSVC_NET_LOCAL_SMF"
            DEPREQ="$DEPREQ_NET_LOCAL_SMF" ;;
        network)
            DEPSVC="$DEPSVC_NET_FULL_SMF"
            DEPREQ="$DEPREQ_NET_FULL_SMF" ;;
        '') ;;
        *)  echo "WARNING: Unexpected NUT media type ignored: '$_MED'" >&2 ;;
    esac
    if [ -n "$DEPSVC" ]; then
        echo "Adding '$DEPREQ' dependency for '$1' on '$DEPSVC'..."
    fi

    /usr/sbin/svcadm refresh 'nut-driver:'"$1" || return
    if [ "$AUTO_START" = yes ] ; then
        /usr/sbin/svcadm enable 'nut-driver:'"$1" || return
    fi
}
smf_unregisterInstance() {
    /usr/sbin/svcadm disable -ts 'nut-driver:'"$1" || false
    /usr/sbin/svccfg -s nut-driver delete "$1"
}
smf_listInstances() {
    # Newer versions have pattern matching; older SMF might not have this luxury
    /usr/bin/svcs -a -H -o fmri | egrep '/nut-driver:' | sed 's/^.*://' | sort -n
}

systemd_registerInstance() {
    /bin/systemctl enable 'nut-driver@'"$1" || return

    DEPSVC=""
    DEPREQ=""
    _MED="`upsconf_getMedia "$1"`"
    case "$_MED" in
        usb)
            DEPSVC="$DEPSVC_USB_SYSTEMD"
            DEPREQ="$DEPREQ_USB_SYSTEMD" ;;
        network-localhost)
            DEPSVC="$DEPSVC_NET_LOCAL_SYSTEMD"
            DEPREQ="$DEPREQ_NET_LOCAL_SYSTEMD" ;;
        network)
            DEPSVC="$DEPSVC_NET_FULL_SYSTEMD"
            DEPREQ="$DEPREQ_NET_FULL_SYSTEMD" ;;
        '') ;;
        *)  echo "WARNING: Unexpected NUT media type ignored: '$_MED'" >&2 ;;
    esac
    if [ -n "$DEPSVC" ]; then
        echo "Adding '$DEPREQ' dependency for '$1' on '$DEPSVC'..."
    fi

    if [ "$AUTO_START" = yes ] ; then
        /bin/systemctl start --no-block 'nut-driver@'"$1" || return
    fi
}
systemd_unregisterInstance() {
    /bin/systemctl stop 'nut-driver@'"$1" || false
    /bin/systemctl disable 'nut-driver@'"$1"
    # TODO: Remove dir with custom dependencies if present
}
systemd_listInstances() {
    /bin/systemctl show 'nut-driver@*' -p Id | egrep '=nut-driver' | sed -e 's/^.*@//' -e 's/\.service$//' | sort -n
}

upslist_readFile() {
    # Read the ups.conf file and find all defined sections (names of
    # configuration blocks for drivers that connect to a certain device
    # using specified protocol and media)
    if [ -n "$UPSCONF" ] && [ -f "$UPSCONF" ] && [ -r "$UPSCONF" ]; then
        [ -s "$UPSCONF" ] && \
        UPSCONF_DATA="$(egrep '[\[\=]' < "$UPSCONF" | sed -e 's,^[\t\ ]*,,' -e 's,^\#.*$,,' -e 's,[\t\ ]*$,,' -e 's,[\t\ ]*=[\t\ ]*,=,g' -e 's,=\"\([^\ \t]*\)\"$,=\1,' | egrep '^(\[.*\]|driver=|port=)')" || \
        UPSCONF_DATA=""
    else
        echo "FATAL: The '$UPSCONF' file does not exist or is not readable" >&2
        return 2
    fi

    [ -n "$UPSCONF_DATA" ] && \
        UPSLIST_FILE="$(echo "$UPSCONF_DATA" | egrep '^\[.*\]$' | sed 's,^\[\(.*\)\]$,\1,' | sort -n)" || UPSLIST_FILE=""
    if [ -z "$UPSLIST_FILE" ] ; then
        echo "Error reading the '$UPSCONF' file or it does not declare any device configurations" >&2
        # Ok to continue - we may end up removing all instances
    fi
}

upslist_readSvcs() {
    UPSLIST_SVCS="`$hook_listInstances`" || UPSLIST_SVCS=""
    if [ -z "$UPSLIST_SVCS" ] && [ "$1" != "-" ] ; then
        EXPLAIN=""
        [ -z "$1" ] || EXPLAIN=" - $1"
        echo "Error reading the list of ${SERVICE_FRAMEWORK-} service instances for UPS drivers, or none are defined${EXPLAIN}" >&2
        # Ok to continue - we may end up defining new instances
    fi
}

upslist_debug() {
    for UPSF in $UPSLIST_FILE ; do
        upsconf_debug "$UPSF"
    done
}

upslist_addSvcs() {
    for UPSF in $UPSLIST_FILE ; do
        if ! common_isRegistered "$UPSF" ; then
            echo "Adding new ${SERVICE_FRAMEWORK} service instance for power device [${UPSF}]..." >&2
            $hook_registerInstance "$UPSF"
        fi
    done
}

upslist_delSvcs() {
    for UPSS in $UPSLIST_SVCS ; do
        if ! common_isFiled "$UPSS" ; then
            echo "Dropping old ${SERVICE_FRAMEWORK} service instance for power device [${UPSS}] which is no longer in config file..." >&2
            $hook_unregisterInstance "$UPSS"
        fi
    done
}

################# MAIN PROGRAM

upslist_readFile || exit $?
upslist_debug
upslist_readSvcs "before manipulations"

# Quickly exit if there's nothing to do; note the lists are pre-sorted
# Otherwise a non-zero exit will be done below
[ "$UPSLIST_FILE" = "$UPSLIST_SVCS" ] && exit 0

if [ -n "$UPSLIST_FILE" ]; then
    upslist_addSvcs
    upslist_readSvcs "after checking for new config sections to define service instances"
fi

if [ -n "$UPSLIST_SVCS" ]; then
    upslist_delSvcs
fi

upslist_readSvcs
if [ -n "$UPSLIST_SVCS" ] ; then
    echo "=== The currently defined service instances are:"
    echo "$UPSLIST_SVCS"
fi

if [ -n "$UPSLIST_FILE" ] ; then
    echo "=== The currently defined configurations in '$UPSCONF' are:"
    echo "$UPSLIST_FILE"
fi

# Return 42 if there was a change applied succesfully
# (but e.g. some services should restart - upsd, maybe upsmon)
[ "$UPSLIST_FILE" = "$UPSLIST_SVCS" ] && return 42
exit 13
