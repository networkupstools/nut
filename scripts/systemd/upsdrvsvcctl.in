#!/bin/sh
#
# Copyright (C) 2016-2017 Eaton
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#! \file    upsdrvsvcctl(.in)
#  \author  Jim Klimov <EvgenyKlimov@eaton.com>
#  \brief   Manage NUT devices registered as service-unit instances
#

ENUMERATOR="@NUT_LIBEXECDIR@/nut-driver-enumerator.sh"

usage() {
    # Note: version header differs from UPS_VERSION in binaries that
    # might also have the git-version suffixed during build time
    cat << EOF
Network UPS Tools - UPS driver controller ${PACKAGE_VERSION}
Starts and stops UPS drivers via system service instances, see
the $ENUMERATOR
script for more details.

usage: $0 [OPTIONS] (start | stop | shutdown) [<ups>]

Options:
  -h            	display this help
  -t            	testing mode - prints actions without doing them
  -D            	raise debugging level
  start         	start all UPS drivers in ups.conf
  start <ups>   	only start driver for UPS <ups>
  stop          	stop all UPS drivers in ups.conf
  stop <ups>    	only stop driver for UPS <ups>

usage: $0 [OPTIONS] resync
  resync        	call $ENUMERATOR
                	to update the mapping of service instances for
                	NUT drivers to device sections in 'ups.conf'

Note: the "shutdown" options from original upsdrvctl are not currently
supported by this service management framework wrapper:
# shutdown      	shutdown all UPS drivers in ups.conf
# shutdown <ups>	only shutdown UPS <ups>
EOF
}

ACTION=""
SVCINST=""
DRYRUN=""
DEBUG=0
# Note: DEBUG is UNUSED_PARAM so far
while [ $# -gt 0 ]; do
    case "$1" in
        resync) eval $DRYRUN $ENUMERATOR ; exit $? ;;
        start|stop)
            if [ -n "$2" ] ; then
                SVCINST="`$ENUMERATOR --get-service-for-device "$2"`" || exit
                shift
            fi
            ACTION="$1" ;;
        shutdown)   echo "Action '$1' is not implemented via services currently" >&2 ; exit 1 ;;
        -t) DRYRUN="echo" ;;
        -h) usage; exit 0 ;;
        -d) DEBUG="`expr $DEBUG + 1`" ;;
        -r|-u) echo "Option '$1 $2' is not implemented via services currently" >&2 ; shift;;
        *)  echo "Unrecognized argument: $1" >&2 ; exit ;;
    esac
    shift
done

if [ -z "$ACTION" ]; then
    echo "No action was requested!" >&2
    exit 1
fi

if [ -z "$SVCINST" ]; then
    SVCINST="`$ENUMERATOR --list-services`" || exit
fi

if [ -z "${SERVICE_FRAMEWORK-}" ] ; then
    [ -x /usr/sbin/svcadm ] && [ -x /usr/sbin/svccfg ] && [ -x /usr/bin/svcs ] && \
        SERVICE_FRAMEWORK="smf"
    [ -z "${SERVICE_FRAMEWORK-}" ] && \
        [ -x /bin/systemctl ] && \
        SERVICE_FRAMEWORK="systemd"
fi

VERB=""
CMD=""
CMDARG=""
case "$SERVICE_FRAMEWORK" in
    smf) CMD="/usr/sbin/svcadm" ;;
    systemd) CMD="/bin/systemctl" ;;
    *)  echo "Unrecognized SERVICE_FRAMEWORK: $SERVICE_FRAMEWORK" >&2 ; exit ;;
esac

# TODO: Support shutdown of one or all UPSes by stopping its service
# and then calling the original upsdrvctl on it?
case "$ACTION" in
    start)
        VERB="Starting"
        case "$SERVICE_FRAMEWORK" in
            smf) CMDARG="enable -t" ;;
            systemd) CMDARG="start" ;;
        esac
        ;;
    stop)
        VERB="Stopping"
        case "$SERVICE_FRAMEWORK" in
            smf) CMDARG="disable -t" ;;
            systemd) CMDARG="stop" ;;
        esac
        ;;
    *)  echo "Unrecognized ACTION: $ACTION" >&2 ; exit ;;
esac

for INST in $SVCINST ; do
    echo "$VERB $INST ..." >&2
    $DRYRUN $CMD $CMDARG "$INST" &
done

wait
