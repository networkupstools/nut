# GNU Make syntax assumed below

# Be able to run without automade project e.g. `gmake -f Makefile.am dmf`
# Note: then `bld=src=dir of makefile` is assumed below
RM ?= /usr/bin/rm -f
# Take compiler from PATH, may be wrapped with ccache etc.
CC = gcc
CPP = gcc
CXX = g++

mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
current_dir := $(patsubst %/,%,$(dir $(mkfile_path)))

srcdir ?= .
builddir ?= .
top_srcdir ?= ../..
top_builddir ?= ../..
abs_srcdir ?= $(current_dir)
abs_builddir ?= $(current_dir)
abs_top_srcdir ?= $(current_dir)/../..
abs_top_builddir ?= $(current_dir)/../..

AM_CFLAGS = -I$(top_builddir)/include -I$(top_srcdir)/include \
    -I$(top_srcdir)/drivers -I$(top_srcdir)/tools/nut-scanner

# Note: this causes a private build of dmf-reindex with debugging etc. which
# may be slightly different from the distributed `nut-scanner-reindex-dmfsnmp`
PROGS = dmf-test dmf-reindex
PROGS_EXPERIMENTAL = dmf-lua-test

DMFSNMP_SUBDIR = dmfsnmp
DMFNUTSCAN_SUBDIR = dmfnutscan

# Automake installation
dmfsnmpdir = @dmfsnmpdir@
dmfsnmp_DATA = $(wildcard $(DMFSNMP_SUBDIR)/*.dmf) dmfsnmp.xsd

dmfnutscandir = @dmfnutscandir@
dmfnutscan_DATA = $(wildcard $(DMFNUTSCAN_SUBDIR)/*.dmf) dmfnutscan.xsd

EXTRA_DIST = $(dmfsnmp_DATA) $(dmfnutscan_DATA)

# Strings must verbatim match the XSD (no trailing slash etc.)
XSD_DMFNUTSCAN_VERSION='1.0.0'
XSD_DMFNUTSCAN_XMLNS='http://www.networkupstools.org/dmf/snmp/nutscan'

# This does not rely on automake semantics, so this Makefile.am can be directly
# used and changed during development without reconfiguring all of NUT sources
DMFTEST_SRC = dmf-test.c
EXTRA_DIST += $(DMFTEST_SRC)

# First target is default
all: progs dmf

clean: clean-local

clean-local:
	$(RM) $(PROGS) $(DMFSNMP_SUBDIR)/*.o \
		$(DMFSNMP_SUBDIR)/*.dmf.tmp $(DMFSNMP_SUBDIR)/*.json.tmp \
		$(DMFSNMP_SUBDIR)/*_TEST.c $(DMFSNMP_SUBDIR)/*_TEST.exe

check: check-local

check-local: progs run-dmf-test

check-experimental: progs-all check-local run-dmf-lua-test

# Recipes to build DMF files with the sources and tools we have.
# NOTE: At a later stage, when the legacy ways are deprecated and %=*-mib.c are
# removed, these DMF files would become redistributable contents by themselves.
# TODO: add tests whether we can build this (pycparser available)
$(DMFSNMP_SUBDIR)/%-mib.dmf: $(abs_top_srcdir)/drivers/%-mib.c dmfify-mib.sh jsonify-mib.py xmlify-mib.py
	mkdir -p $(@D)
	cd $(@D) && $(abs_srcdir)/dmfify-mib.sh $<

# We can not touch read-only source dirs (e.g. during distcheck) so make sure
# that we use builddir for this final touch. The DMF files themselves may be
# prebuilt and distributed as source, the gmake VPATH should figure that out.
# This may cause harmless "circular dependency" notices during in-tree builds.
# However, the dmf-reindexer is currently hardcoded to use only one directory,
# so we copy stuff below just in case (if needed).
$(DMFSNMP_SUBDIR)/.uptodate: $(builddir)/$(DMFSNMP_SUBDIR)/.uptodate
$(builddir)/$(DMFSNMP_SUBDIR)/.uptodate: $(addprefix $(DMFSNMP_SUBDIR)/,$(patsubst %.c,%.dmf,$(notdir $(wildcard $(abs_top_srcdir)/drivers/*-mib.c))))
	@echo "DMFSNMP_SUBDIR is now up to date, made of: $^" >&2
	mkdir -p $(@D)
	@if [ "$(abs_builddir)" != "$(abs_srcdir)" ]; then \
		for F in "$(abs_srcdir)/$(DMFSNMP_SUBDIR)/"*.dmf ; do \
			B="`basename "$$F"`"; \
			[ "$$B" = '*.dmf' ] && exit 0 ; \
			N="$(abs_builddir)/$(DMFSNMP_SUBDIR)/$$B"; \
			[ -s "$$F" ] && [ ! -s "$$N" ] && \
				echo "  CP    $$F => $$N" >&2 && \
				cp -f "$$F" "$$N" || exit ; \
		done; \
	fi
	touch $@

# The recipe assumes we have separate opening and closing lines in the DMF file
# just generated by reindexer (the "<nut>" and "</nut>" lines) and a randomly
# ordered set of mib2nut lines that we want consistent (no git diff complaints)
# TODO: The proper solution including header lines should be in the C code!
$(DMFNUTSCAN_SUBDIR)/dmfnutscan-snmp.dmf: $(DMFSNMP_SUBDIR)/.uptodate dmf-reindex
	mkdir -p $(@D)
	$(abs_builddir)/dmf-reindex > $@.tmp
	( egrep -v '^$$|\<mib2nut ' "$@.tmp" | head -1 ; \
	  grep '<mib2nut ' "$@.tmp" | sort | uniq ; \
	  egrep -v '^$$|\<mib2nut ' "$@.tmp" | tail -1 ; \
	) > $@
	@sort "$@.tmp" | egrep -v '^$$' | uniq > "$@.tmp1" ; \
	    sort "$@" | egrep -v '^$$' | uniq > "$@.tmp2" ; \
	  diff "$@.tmp1" "$@.tmp2" >/dev/null \
	|| { echo "FAILED to sort generated $@ without losses!" >&2; \
	     rm -f "$@.tmp"* ; exit 1; } ; exit 0
	cp -f "$@" "$@.tmp" && ( \
	    echo '<?xml version="1.0" encoding="UTF-8" ?>' && \
	    sed 's,^<nut>,\<nut version="$(XSD_DMFNUTSCAN_VERSION)" xmlns="$(XSD_DMFNUTSCAN_XMLNS)"\>,' < "$@.tmp" ) > $@
	rm -f "$@.tmp"*

$(DMFNUTSCAN_SUBDIR)/.uptodate: $(builddir)/$(DMFNUTSCAN_SUBDIR)/.uptodate
$(builddir)/$(DMFNUTSCAN_SUBDIR)/.uptodate: $(DMFNUTSCAN_SUBDIR)/dmfnutscan-snmp.dmf
	@echo "DMFNUTSCAN_SUBDIR is now up to date" >&2
	mkdir -p $(@D)
	touch $@

# The *_DATA rules above refer to these strings, satisfy them
$(DMFSNMP_SUBDIR)/*.dmf: $(DMFSNMP_SUBDIR)/.uptodate
$(DMFNUTSCAN_SUBDIR)/*.dmf: $(DMFNUTSCAN_SUBDIR)/.uptodate

# Validation requires xmllint, which we have if we succeed with asciidoc usage
$(DMFSNMP_SUBDIR)/.validated: $(builddir)/$(DMFSNMP_SUBDIR)/.validated
$(builddir)/$(DMFSNMP_SUBDIR)/.validated: $(builddir)/$(DMFSNMP_SUBDIR)/.uptodate
	@cd $(@D) && for F in *.dmf ; do \
	    echo " XMLLINT  $$F"; \
	    xmllint --noout --schema $(abs_srcdir)/dmfsnmp.xsd "$$F" || exit; \
	done

# TODO: Maybe per-DMF *.dmf.validated files would be better?
$(DMFNUTSCAN_SUBDIR)/.validated: $(builddir)/$(DMFNUTSCAN_SUBDIR)/.validated
$(builddir)/$(DMFNUTSCAN_SUBDIR)/.validated: $(builddir)/$(DMFNUTSCAN_SUBDIR)/.uptodate
	@ERRCODE=0; cd $(@D) && for F in *.dmf ; do \
	    echo " XMLLINT  $$F"; \
	    xmllint --noout --schema $(abs_srcdir)/dmfnutscan.xsd "$$F" || ERRCODE=1; \
	done; exit $$ERRCODE

# Make sure all generated DMFs are up to date vs. C sources and recipes
dmf-uptodate: $(DMFSNMP_SUBDIR)/.uptodate $(DMFNUTSCAN_SUBDIR)/.uptodate

# Make sure all present DMFs are valid vs. XSD schema
dmf-validate: dmf-uptodate $(DMFSNMP_SUBDIR)/.validated $(DMFNUTSCAN_SUBDIR)/.validated

if HAVE_ASCIIDOC
  dmf: dmf-validate
else
  dmf: dmf-uptodate
endif

progs: $(PROGS)

progs-all: $(PROGS) $(PROGS_EXPERIMENTAL)

# Note: These recipes are explicit so they can be built without configuring NUT
dmf-test: $(DMFTEST_SRC) $(top_srcdir)/common/dmfsnmp.c $(top_srcdir)/common/str.c
	$(CC) -ggdb -std=c11 -std=gnu99 -Werror -Wall -pedantic -Wc++-compat \
	-D_FORTIFY_SOURCE=2 -O -fstack-protector \
	-lneon $(AM_CFLAGS) \
	-DDEBUG=1 -DDEFAULT_DMFSNMP_DIR_OVERRIDE="\"$(abs_top_builddir)/scripts/DMF/$(DMFSNMP_SUBDIR)\"" \
	-o $@ $^

dmf-reindex: $(top_srcdir)/tools/nut-scanner/nut-scanner-reindex-dmfsnmp.c $(top_srcdir)/common/dmfsnmp.c $(top_srcdir)/common/str.c
	$(CC) -ggdb -std=c11 -std=gnu99 -Werror -Wall -pedantic -Wc++-compat \
	-D_FORTIFY_SOURCE=2 -O -fstack-protector \
	-lneon $(AM_CFLAGS) \
	-DDEBUG=1 -DDEFAULT_DMFSNMP_DIR_OVERRIDE="\"$(abs_top_builddir)/scripts/DMF/$(DMFSNMP_SUBDIR)\"" \
	-o $@ $^

dmf-lua-test: $(DMFTEST_SRC) $(top_srcdir)/common/dmfsnmp.c $(top_srcdir)/common/str.c
	$(CC) -ggdb -std=c11 -std=gnu99 -Werror -Wall -pedantic -Wc++-compat \
	-D_FORTIFY_SOURCE=2 -O -fstack-protector \
	-lneon $(AM_CFLAGS) \
	-llua5.1 -I/usr/include/lua5.1 -DWITH_DMF_LUA=1 \
	-DDEBUG=1 -DDEFAULT_DMFSNMP_DIR_OVERRIDE="\"$(abs_top_builddir)/scripts/DMF/$(DMFSNMP_SUBDIR)\"" \
	-o $@ $^

# Note: DMF dirs are currently hardcoded (above) so no big need to "cd" anywhere
# But some data should be prepopulated there before we run leak tests etc.
run-dmf-test: dmf-test $(DMFSNMP_SUBDIR)/.uptodate
	cd $(DMFSNMP_SUBDIR) && valgrind --leak-check=full $(abs_builddir)/$<

run-dmf-reindex: dmf-reindex $(DMFSNMP_SUBDIR)/.uptodate
	cd $(DMFSNMP_SUBDIR) && valgrind --leak-check=full $(abs_builddir)/$<

run-dmf-lua-test: dmf-lua-test $(DMFSNMP_SUBDIR)/.uptodate
	cd $(DMFSNMP_SUBDIR) && valgrind --leak-check=full --track-origins=yes $(abs_builddir)/$<
