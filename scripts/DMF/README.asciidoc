# DMF - Device Mapping File

## Abstract

The aim is to develop a solution allowing to modify or even add new NUT
SNMP (only, right now) MIBs mappings without having to recompile the binary
driver (`snmp-ups`) or the whole NUT source. Support for DMF requires linking
with the `libneon` XML parser, already used in `netxml-ups` NUT driver.

The present solution is a first iteration to read this information from an
external file (XML formatted). The `*-mib.c` files present in the vanilla
NUT sources at this time have been processed to produce `*.dmf` data files
ready for dynamic loading at end-user installations. Conversion tools are
also distributed in this iteration, see their chapter below. They do bring
some Python dependency requirements, but are not strict requirements for
NUT (as common-case nor `distcheck` builds) -- the tools are only intended
for manual usage by a few developers.

As something between conversion tools and a sample program, the `dmf-reindex`
code is provided to read the library of complete DMFs (and validate their
contents along the way), and produce a DMF file that only contains truncated
`mib2nut` entries as needed for the `nut-scanner`. This `dmf-reindex` program
is expected to become an end-user tool, to help during updates of the DMF set.

Overview of DMF usage from C code is maintained in the `dmf.h` file, driver
and application developers should look there for the "The big theory" details.

A second iteration is experimentally provided, but may be incomplete and is
subject to change after some team discussions, which is to support not only
static mappings of the first iteration (so as to be functionally and logically
equivalent to the pre-DMF code), but also add support for dynamic mappings
using an interpreted language. LUA is the first implementation in the works,
so it would be the default option (given experimental status, it is not
compilable by default unless you define `-DWITH_DMF_LUA=1` to the compiler
command-line or `CFLAGS`; also the implementation is currently compatible
with LUA-5.1 or *older* -- so the include-file path and library name should
match your OS distribution's naming for this version).

## XML spec

The DMF files are implemented as XML with a particular schema.

There are *4* main structures in the DMF XML:
 * `info_lkp_t`: mapping between NUT and SNMP values for a variable
 * `alarms_info_t`: mapping between NUT and SNMP `ups.alarm` values for a variable
 * `snmp_info_t`: mapping between NUT variables and SNMP OIDs
 * `mib2nut_info_t`: declaration of discovery and mapping (`snmp_info_t`)
    information

### LOOKUP

----
<nut>
    <lookup name="ats_output_status_info">
        <item oid = "1" info = "OFF" />
    </lookup>
</nut>
----

## Tools

For the sake of future temporary co-existence of legacy and DMF-enhanced
implementations of `snmp-ups` as a fall-back solution or for peace of mind
for conservative users, and even more as an aid to the deviated downstream
NUT forks that might have modified MIB files (perhaps in-house NUT builds
of some end-users), the tools we made to convert existing C-structure MIB
implementations to such external DMF files are also distributed here.

Before using the scripts, make sure you have run `./autogen.sh && ./configure`
in the root of NUT sources tree and generally can build NUT (the `pycparser`
tries to compile instrumented sources, and requires the toolchain as well as
the `config.h` file generated by `configure` script).

They are a mix of Python and shell scripts:

 * `jsonify-mib.py`: process MIB mapping from C source and print it to stdout
    as JSON
 * `xmlify-mib.py`: process JSON output produced by `jsonify-mib.py` and output
    the final DMF XML format
 * `dmfify-mib.sh`: execute this from the `$NUT_SOURCE/scripts/DMF/` directory
    and it will find and process existing `../../drivers/*-mib.c` files to feed
    them into the pipeline of the two scripts above and produce `*.dmf` files.
    It calls `jsonify-mib.py --test` so the parsed structures are recreated
    into a C file, compiled and instantly tested to make sure they match.

NOTE: At this time the Python scripts are not intended for direct execution
(exec bits not set), so you should prepend them with versioned parser name
(e.g. `python2.7 jsonify-mib.py`). If your system default version is Python-2.x
then just `python` program name may suffice.

### jsonify-mib.py

Tool parses `*-mib.c` files (picking `snmp_info_t` and `info_lkp_t` structures)
and prints the output of those as JSON. Note this is NOT intended as final DMF
form, this JSON markup is an intermediate form for easier processing.

You need Python version 2.7 with an `argparse` module, as well as a separate
`pycparser` installed to run it:

 * via your package management
   As an example, you can do so:

  ** on Debian and derivative systems, using:

----
    # apt-get install python-pycparser
----

   and / or

----
    # apt-get install python3-pycparser
----

  ** on Redhat and derivative systems, using:

----
    # yum install <... to be completed>
----

  ** on OpenIndiana and similar systems, using:

----
    # pkg install -v pycparser
----

   and / or specifically

----
    # pkg install pycparser-27
----


 * or using `pip`:

----
    virtualenv dmf
    source dmf/bin/activate
    pip install -e pycparser
----

Usage is then:

----
    $ python2.7 jsonify-mib.py ../../drivers/apc-ats-mib.c
    {
        "INFO": {
            "ats_output_status_info": {
                "1": "OFF",
                "2": "OL"
            },
            "ats_sensitivity_info": {
                "1": "high",
                "2": "low"
            },
    ...
----

### xmlify-mib.py

Assming you have installed Python e.g. using instructions above, you can
produce final DMF XML markup from the intermediate JSON by simply piping
it to the standard input of this script:

----
    $ python2.7 xmlify-mib.py < apc-ats-mib.json > apc-ats-mib.dmf
----

You can also build a pipeline of these two scripts, which is essentially
what `dmfify-mib.sh` is for.

